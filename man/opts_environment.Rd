% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/environment.R
\name{opts_environment}
\alias{opts_environment}
\title{Constructive options for type 'environment'}
\usage{
opts_environment(
  constructor = c("list2env", "as.environment", "new.env", "topenv", "new_environment"),
  ...,
  recurse = FALSE,
  predefine = FALSE
)
}
\arguments{
\item{constructor}{String. Name of the function used to construct the environment, see Details section.}

\item{...}{Should not be used. Forces passing arguments by name.}

\item{recurse}{Boolean. Only considered if \code{constructor} is \code{"list2env"} or \code{"new_environment"}. Whether to
attempt to recreate all parent environments until a known environment is found,
if \code{FALSE} (the default) we will use \code{topenv()} to find a known ancestor to set as
the parent.}

\item{predefine}{Boolean. Whether to define environments first. If \code{TRUE} \code{constructor} and \code{recurse}
are ignored. This is the most faithful approach as it circumvents the circularity
and recursivity issues of available constructors. The caveat is that the created code
won't be a single call and will create objects in the workspace.}
}
\value{
An object of class <constructive_options/constructive_options_environment>
}
\description{
Constructive options for type 'environment'
}
\details{
Environments use reference semantics, they cannot be copied.
An attempt to copy an environment would indeed yield a different environment and \code{identical(env, copy)} would be \code{FALSE}.\cr
Moreover every environment (except for \code{emptyenv()}) has a
parent and thus to copy the environment we'd have to have a way to point to
the parent, or copy it too.\cr
For this reason environments are {constructive}'s cryptonite. They make some objects
impossible to reproduce exactly. And since every function or formula has one they're hard to
avoid \cr
Luckily in many cases we don't need a perfect copy of an environment to reproduce
an object faithfully from a practical standpoint, and in a some cases we might build
code that points to a specific environment such as \code{.GlobalEnv} or a given namespace.\cr
{constructive} will not signal any difference if it can reproduce an equivalent environment,
defined as containing the same values and having a same or equivalent parent.\cr
See also the \code{ignore_function_env} argument in \code{?construct}, which disables the check
of environments of function.

Environment construction works as follows:
\itemize{
\item Special environments \code{.GlobalEnv}, \code{.BaseNamespaceEnv}, \code{baseenv()} and
\code{emptyenv()} are used whenever possible.
\item The idiom \code{asNamespace("pkg")} is
used whenever possible.
\item The idiom \code{as.environment("package:pkg")} is used
whenever possible.
\item The \code{constructor} argument is used to recreate a similar environment whenever
the above conditions are not met.
}

Depending on \code{constructor}, we construct the environment as follows:
\itemize{
\item \code{"list2env"} (default): We construct the environment as a list then
use \code{base::list2env()} to convert it to an environment and assign it a parent. By
default we will use \code{base::topenv()} to construct a parent. If \code{recurse} is \code{TRUE}
the parent will be built recursively so all ancestors will be created until
we meet a known environment, this might be verbose and will fail if environments
are nested too deep or have a circular relationship, but if it works it's the
most faithful method. If the environment is empty we use \code{new.env(parent=)}
for a more economic syntax.
\item \code{"new_environment"} : Similar to the above, but using \code{rlang::new_environment()}.
\item \code{"new.env"} : All environments will be recreated with the code \code{"base::new.env()"}, effectively creating an empty environment child of
the local (often global) environment. This is enough in cases where the environment
doesn't matter at all (or matters as long as it inherits from the local environment),
this is the case for most formulas. \code{recurse} is ignored.
\item \code{"as.environment"} : we attempt to construct the environment as a list and use
\code{base::as.environment()} on top of it, as in \code{as.environment(list(a=1, b=2))}, it will
contain the same variables as the original environment but the parent will be the
\code{emptyenv()}. \code{recurse} is ignored.
\item \code{"topenv"} : we construct \code{base::topenv(x)}, see \code{?topenv}. \code{recurse} is ignored.
}
}

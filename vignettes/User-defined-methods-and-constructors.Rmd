---
title: "Extending {constructive}"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Extending-constructive}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all()
```

We detail in this vignette how {constructive} works and how
you might define custom constructors or custom `construct_raw.?()` methods.

To define new constructors you need to :

* Define a constructor function in your package, along with a repair function to
  fix attributes.
* Call `constructive::register_constructors()` in your package

To support a new class you additionally need to define :

* `construct_raw.your_class()`
* `opts_your_class()`
* `is_corrupted_your_class()`

We provide the general theory here but you are encouraged to look at examples.
All the scripts starting with "s3-" in this package contain everything necessary
to support a given class using various constructors and it is probable that the
class you want to support shares similarities with one that is already supported.

The package is young and subject to breaking changes, so we apologize in advance
for the possible API breaking changes in the future.

## Recursion system

* `construct()` wraps `construct_raw()`. 
* `construct_raw()` builds code recursively, without checking input or output validity, 
  without handling errors, and without formatting.
* `construct()` does this extra work.
* `construct_raw()` is a generic and many methods are implemented in the package, for
  instance `construct(iris)` will call `construct_raw.data.frame()` which down the line
  will call `construct_raw.numeric()` and `construct_raw.factor()` to construct its columns.
* Additionally, before dispatching, `construct_raw()` attempts to match its data input
  to a list of objects provided to the `data` argument.

## `construct_raw.?()` methods

`construct_raw.?()` methods typically have this form:

```{r}
construct_raw.Date <- function(x, ...) {
  opts <- fetch_opts("Date", ...)
  if (is_corrupted_Date(x) || opts$constructor == "next") return(NextMethod())
  constructor <- constructors$Date[[opts$constructor]]
  constructor(x, ..., origin = opts$origin)
}
```

* `fetch_opts()` gathers options provided to `construct()` through the `opts_*()` function
  introduced in the next section, or fall back to a default value if none were provided.
* If the object is corrupted or if the user decided to bypass the current method by
  choosing "next" as a constructor for this class, we return `NextMethod()` to
  forward all our inputs to a lower level constructor.
* `constructor()` actually builds the code from the object `x`, the parameters forwarded
  through `...` and the optional construction details gathered in `opts` (here the `origin`)

## `opts_?()` function

When implementing a new method you'll need to define and export the corresponding
`opts_?()` function. It provides to the user a way to choose a constructor and 
object retrieved by `fetch_opts()` in the `construct_raw()` method.

It always has this form:

```{r}
opts_Date <- function(
    constructor = c(
      "as.Date", "as_date", "date", "new_date",  "as.Date.numeric", 
      "as_date.numeric", "next", "atomic"
    ),
    ..., 
    origin = "1970-01-01"
  ) {
  combine_errors(
    constructor <- rlang::arg_match(constructor),
    ellipsis::check_dots_empty()
  )
  constructive_options("Date", constructor = constructor, origin = origin)
}
```

* The class is present in the name of the `opts_?()` function and as the first
  argument of `constructive_options()`.
* A character vector of constructors is provided, starting with the default constructor
 and ending with `"next"` and the constructor for the corresponding internal type.
* Additional arguments passed to the constructors might be added, as we did here with
  `origin`
 
The following code illustrates how the information is retrieved.

```{r}
# fetch_opts() takes a class and the dots and retrieves the relevant options
# if none were provided it falls back on the default value for the relevant opts_?() function
test <- function(...) {
  fetch_opts("Date", ...)
}
test(opts_Date("as_date"), opts_data.frame("read.table"))
test()
```
## `is_corrupted_?()` function

`is_corrupted_?()` checks if `x` has the right internal type and attributes,
sometimes structure, so that it satisfies the expectations of a well formatted object
of a given class.

If an object is corrupted for a given class we cannot use constructors for this
class, so we move on to a lower level constructor by calling `NextMethod()` in
`construct_raw()`.

This is important so that `{constructive}` doesn't choke on corrupted objects but
instead helps us understand them.

For instance in the following example `x` prints like a date but it's corrupted,
a date should not be built on top of characters and this project cannot be built
with `as.Date()` or other idiomatic date constructors.

```{r, error = TRUE}
x <- structure("12345", class = "Date")
x
x + 1
```

We have defined : 

```{r}
is_corrupted.Date <- function(x) {
  !is.double(x)
}
```

And as a consequence the next method, `construct_raw.default()` will be called
through `NextMethod()` and will handle the object using an atomic vector constructor:

```{r}
construct(x)
```

## constructors

{constructive} exports a `constructors` environment object, itself containing
environments named like classes, the latter contain the constructor functions.

It is retrieved in the `construct_raw()` method by:

```{r, eval = FALSE}
constructor <- constructors$Date[[opts$constructor]]
```

For instance the default constructor for "Date" is :

```{r}
constructors$Date$as.Date
```

A constructor's role is to apply a constructor and to recurse to construct its inputs,
this is done by using `construct_apply()` once these output have been prepared. In
the case above we have 2 logical paths because dates can be infinite but date vectors
containing infinite elements cannot be represented by `as.Date(<character>)`, our
preferred choice.

```{r}
x <- structure(c(12345, 20000), class = "Date")
y <- structure(c(12345, Inf), class = "Date")
constructors$Date$as.Date(x)
constructors$Date$as.Date(y)
```
It's important to consider corner cases when defining a constructor,
if some cases can't be handled by the constructor we should fall back to another
constructor or to another `construct_raw()` method.

For instance `constructors$data.frame$read.table()` falls back on 
`constructors$data.frame$data.frame()`  when the input contains non atomic columns,
which cannot be represented in a table input, and `constructors$data.frame$data.frame()`
itself falls back on `construct_raw.list()` when the data frame contains list columns not defined using `I()`, since `data.frame()` cannot produce such objects.

Constructors should always end by a call to a repairing function.

## Repairing functions

Repairing functions adjust the attributes of an object after idiomatic constructors such as `as.Date()` have defined their data and canonical attributes.

```{r}
x <- structure(c(12345, 20000), class = "Date", some_attr = 42)
# attributes are not visible due to "Date"'s printing method
x

# but thanks to the repairing function, constructive retrieves them
constructors$Date$as.Date(x)
```

Repairing functions are generally wrappers around `repair_attributes_impl()`,
a function that essentially sets attributes with exceptions :

* It doesn't set names, as they are provided by the constructors
* It doesn't set the class explicitly if it's identical to the idiomatic class, i.e. the
  class returned by the constructor before the repair call, and provided through the
  `idiomatic_class` argument
* It doesn't set attributes that we choose to ignore because they are set by the
  constructor.

`repair_attributes_impl()` does a bit more but we don't need to dive deeper in this vignette.


```{r}
repair_attributes.Date

repair_attributes.factor
```

## Register a new class

Registering a new class is done just by defining a `construct_raw.?()` method.

## Register new constructors

You should not attempt to modify manually the `constructors` object of the {constructive} package, instead you should :

* Define an unexported constructor function 
* Call `register_constructor(class_name, constructor_function)` 

Do the latter in `.onload()` if the new constructor is to be part of a package,
for instance.


```{r, eval = FALSE}
# in zzz.R
.onLoad <- function(libname, pkgname) {
  register_constructors(
    class_name, 
    constructor_name1 = constructor1, 
    constructor_name2 = constructor2
  )
}
```
